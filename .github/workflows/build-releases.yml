---
# Build Release for GDAL Version
#
# Manual workflow dispatch to build gdalcli for a specific GDAL version.
# Generates API, runs tests, and creates release branch and GitHub release.
#
# Strategy:
# - Uses pre-built deps-gdal-X.Y.Z-amd64 images from build-docker-images.yml
# - Builds gdalcli-runtime image with API generation and package tests
# - Creates release branch and GitHub release on main branch
#
name: Build Release for GDAL Version

on:
  workflow_dispatch:
    inputs:
      gdal_version:
        description: |
          GDAL version to build for (e.g., 3.11.4, 3.12.0)
        required: true
      create_release:
        description: 'Create GitHub release and tag? (only effective on main branch)'
        required: true
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      dry_run:
        description: 'Dry run mode: skip branch/release creation and image push'
        required: true
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  contents: write
  packages: write

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      gdal_version: ${{ steps.parse.outputs.gdal_version }}
      gdal_short: ${{ steps.parse.outputs.gdal_short }}
      package_version: ${{ steps.parse.outputs.package_version }}
      branch_name: ${{ steps.parse.outputs.branch_name }}
      tag_name: ${{ steps.parse.outputs.tag_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Validate and parse GDAL version
        id: parse
        run: |
          VERSION="${{ github.event.inputs.gdal_version }}"

          # Validate semver format (X.Y.Z)
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Invalid version format: $VERSION (expected X.Y.Z)"
            exit 1
          fi

          # Extract major.minor
          SHORT=$(echo "$VERSION" | cut -d. -f1-2)

          # Validate >= 3.11
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)

          if (( MAJOR < 3 )) || (( MAJOR == 3 && MINOR < 11 )); then
            echo "ERROR: GDAL version must be >= 3.11 (got $VERSION)"
            exit 1
          fi

          # Validate version exists in versions.json (if file exists)
          if [ -f .github/versions.json ]; then
            SUPPORTED=$(jq -r '.supported[]' .github/versions.json)
            if ! echo "$SUPPORTED" | grep -q "^${VERSION}$"; then
              echo "WARNING: Version $VERSION not in supported list from .github/versions.json"
              echo "Supported versions: $(echo $SUPPORTED | tr '\n' ', ')"
              echo "Proceeding anyway (you can add it to versions.json if this is new)"
            fi
          fi

          # Extract package version from DESCRIPTION
          PKG_VERSION=$(grep "^Version:" DESCRIPTION | sed 's/Version: //')
          
          if [ -z "$PKG_VERSION" ]; then
            echo "ERROR: Could not extract package version from DESCRIPTION"
            exit 1
          fi

          BRANCH="release/gdal-${SHORT}"
          TAG="v${PKG_VERSION}-${VERSION}"

          echo "gdal_version=$VERSION" >> $GITHUB_OUTPUT
          echo "gdal_short=$SHORT" >> $GITHUB_OUTPUT
          echo "package_version=$PKG_VERSION" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG" >> $GITHUB_OUTPUT

          echo "Validated GDAL $VERSION"
          echo "  Package Version: $PKG_VERSION"
          echo "  Branch: $BRANCH"
          echo "  Tag: $TAG"

      - name: Check deps image availability
        run: |
          VERSION="${{ steps.parse.outputs.gdal_version }}"
          IMAGE="ghcr.io/${{ github.repository }}:deps-gdal-${VERSION}-amd64"
          
          echo "Checking for deps image: $IMAGE"
          
          # Note: docker buildx imagetools requires authentication for private images
          # For now, we'll just verify the image exists by trying to use it in a build
          # The actual build will fail if the image doesn't exist

  build:
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Check OSGeo GDAL image availability
        id: check-image
        run: |
          GDAL_VERSION="${{ needs.validate.outputs.gdal_version }}"

          TAGS_TO_TRY=(
            "ubuntu-small-${GDAL_VERSION}-amd64"
            "ubuntu-small-${GDAL_VERSION}"
            "ubuntu-small-latest-amd64"
            "ubuntu-small-latest"
            "ubuntu-small-amd64"
            "ubuntu-small"
            "latest"
          )

          SELECTED_TAG=""
          for TAG in "${TAGS_TO_TRY[@]}"; do
            IMAGE_TAG="ghcr.io/osgeo/gdal:${TAG}"
            echo "Checking: $IMAGE_TAG"

            if docker buildx imagetools inspect "$IMAGE_TAG" >/dev/null 2>&1; then
              echo "Found OSGeo GDAL image: $IMAGE_TAG"
              SELECTED_TAG="$TAG"
              break
            fi
          done

          if [ -z "$SELECTED_TAG" ]; then
            echo "No suitable OSGeo GDAL image found for version ${GDAL_VERSION}"
            exit 1
          fi

          echo "selected_gdal_image_tag=$SELECTED_TAG" >> $GITHUB_OUTPUT

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build runtime image for GDAL ${{ needs.validate.outputs.gdal_version }}
        uses: docker/build-push-action@v5
        with:
          context: .
          file: .github/dockerfiles/Dockerfile.template
          target: gdalcli-runtime
          build-args: |
            GDAL_BUILD_MODE=osgeo
            GDAL_VERSION=${{ needs.validate.outputs.gdal_version }}
            GDAL_RELEASE_TYPE=tagged
            GDAL_IMAGE_TAG=${{ steps.check-image.outputs.selected_gdal_image_tag }}
            R_VERSION=latest
            PACKAGE_VERSION=${{ needs.validate.outputs.package_version }}
          tags: |
            ghcr.io/${{ github.repository }}:gdal-${{ needs.validate.outputs.gdal_version }}-latest
          platforms: linux/amd64
          cache-from: type=gha,scope=release-${{ needs.validate.outputs.gdal_version }}
          cache-to: type=gha,mode=max,scope=release-${{ needs.validate.outputs.gdal_version }}
          push: ${{ github.event.inputs.dry_run == 'false' }}
          build-contexts: context=.github/dockerfiles
          outputs: type=docker,dest=/tmp/image.tar

      - name: Load Docker image
        if: github.event.inputs.dry_run == 'false'
        run: |
          docker load --input /tmp/image.tar

      - name: Generate API and build release in Docker
        if: github.event.inputs.dry_run == 'false'
        run: |
          GDAL_VERSION="${{ needs.validate.outputs.gdal_version }}"
          IMAGE="ghcr.io/${{ github.repository }}:gdal-${GDAL_VERSION}-latest"
          
          # Generate API and documentation inside Docker where GDAL is available
          docker run --rm \
            -v "$PWD:/workspace" \
            -w /workspace \
            "$IMAGE" \
            bash -c "
              set -e
              
              echo 'Generating GDAL API in workspace...'
              Rscript /workspace/build/generate_gdal_api.R
              
              echo 'Generating documentation...'
              Rscript -e 'roxygen2::roxygenise()'
              
              # Run checks on the generated package
              echo 'Running R CMD check...'
              R CMD check --no-manual --compact-vignettes=gs+qpdf /workspace 2>&1 | tail -50 || {
                echo 'WARNING: R CMD check had issues, but continuing...'
              }
              
              # Show generated files
              echo ''
              echo 'Generated files summary:'
              echo \"R files: \$(ls -1 /workspace/R/*.R 2>/dev/null | wc -l)\"
              echo \"Rd files: \$(ls -1 /workspace/man/*.Rd 2>/dev/null | wc -l)\"
              test -f /workspace/NAMESPACE && echo 'NAMESPACE: OK' || echo 'NAMESPACE: MISSING'
            "
          
          # Verify files exist in workspace (should be source .R files, not binaries)
          echo ""
          echo "Verifying generated files in workspace..."
          test -d R && ls -lh R/*.R 2>/dev/null | head -3 || echo "✗ R/ missing source files!"
          test -d man && echo "✓ man/ directory exists ($(ls -1 man/*.Rd 2>/dev/null | wc -l) files)" || echo "✗ man/ directory missing!"
          test -f NAMESPACE && echo "✓ NAMESPACE exists" || echo "✗ NAMESPACE missing!"
          
          # Sanity check: no binary files should be staged
          if [ -f R/gdalcli ] || [ -f R/gdalcli.rdb ]; then
            echo "ERROR: Binary package files detected in R/ - these should not be staged!"
            ls -la R/
            exit 1
          fi

      - name: Configure git and prepare release branch
        if: github.event.inputs.dry_run == 'false'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

          GDAL_VERSION="${{ needs.validate.outputs.gdal_version }}"
          BRANCH="${{ needs.validate.outputs.branch_name }}"
          GDAL_SHORT="${{ needs.validate.outputs.gdal_short }}"
          
          # Determine if this is a patch version of an existing minor version
          # or a new minor version release
          IS_PATCH_VERSION=false
          
          echo "Checking if branch $BRANCH exists in remote..."
          git fetch origin
          
          if git rev-parse --verify origin/$BRANCH 2>/dev/null; then
            echo "Release branch exists: $BRANCH"
            echo "This is a patch version release (e.g., updating 3.12.0 -> 3.12.1)"
            IS_PATCH_VERSION=true
            
            # For patch version: checkout existing branch and continue from it
            # This preserves prior work for earlier patches
            echo "Checking out existing release branch..."
            git checkout -b $BRANCH origin/$BRANCH
          else
            echo "Release branch does not exist: $BRANCH"
            echo "This is a new minor version release (e.g., first 3.12.x)"
            
            # For new minor version: create branch from main
            echo "Creating new release branch from main..."
            git fetch origin main
            git checkout -b $BRANCH origin/main
          fi
          
          # Clean up R check directory with restricted permissions before stashing
          echo "Cleaning up build artifacts..."
          sudo rm -rf workspace.Rcheck 2>/dev/null || rm -rf workspace.Rcheck
          
          # Stash any uncommitted changes (including untracked generated files)
          echo "Stashing generated files and changes..."
          git stash push -u -m "temp: generated files for $BRANCH (GDAL $GDAL_VERSION)"
          
          # For new minor version only: reset to main to get latest base code
          if [ "$IS_PATCH_VERSION" = false ]; then
            echo "New minor version: resetting to main base..."
            git fetch origin main
            git reset --hard origin/main
          else
            echo "Patch version: continuing on existing branch without reset"
          fi
          
          # Restore the stashed changes (generated files)
          # This must succeed or the workflow should fail
          echo "Restoring generated files..."
          git stash pop

      - name: Update DESCRIPTION
        run: |
          GDAL_VERSION="${{ needs.validate.outputs.gdal_version }}"
          PKG_VERSION="${{ needs.validate.outputs.package_version }}"

          # Update Version field with GDAL suffix
          sed -i "s/^Version:.*/Version: ${PKG_VERSION}-${GDAL_VERSION}/" DESCRIPTION

          # Update SystemRequirements field
          sed -i "s/^SystemRequirements:.*/SystemRequirements: GDAL (>= ${GDAL_VERSION})/" DESCRIPTION

          cat DESCRIPTION | grep -E "^Version:|^SystemRequirements:"

      - name: Update version info and commit release
        if: success() && github.event.inputs.dry_run == 'false'
        run: |
          GDAL_VERSION="${{ needs.validate.outputs.gdal_version }}"
          BUILD_DATE="$(date -I)"
          GENERATED_AT="$(date '+%Y-%m-%d %H:%M:%S')"
          
          # Parse version components
          MAJOR=$(echo "$GDAL_VERSION" | cut -d. -f1)
          MINOR=$(echo "$GDAL_VERSION" | cut -d. -f2)
          PATCH=$(echo "$GDAL_VERSION" | cut -d. -f3)
          
          # Get R and package versions from the Docker image
          IMAGE="ghcr.io/${{ github.repository }}:gdal-${GDAL_VERSION}-latest"
          R_VERSION=$(docker run --rm "$IMAGE" R --version 2>/dev/null | head -1 | sed 's/R version \([0-9.]*\).*/\1/')
          PROCESSX_VERSION=$(docker run --rm "$IMAGE" Rscript --slave -e "cat(as.character(packageVersion('processx')))" 2>/dev/null || echo "unknown")
          JSONLITE_VERSION=$(docker run --rm "$IMAGE" Rscript --slave -e "cat(as.character(packageVersion('jsonlite')))" 2>/dev/null || echo "unknown")
          
          cat > inst/GDAL_VERSION_INFO.json <<EOF
          {
            "generated_at": "$GENERATED_AT",
            "gdal_version": "$GDAL_VERSION",
            "gdal_version_parsed": {
              "full": "$GDAL_VERSION",
              "major": $MAJOR,
              "minor": $MINOR,
              "patch": $PATCH
            },
            "generation_date": "$BUILD_DATE",
            "r_version": "$R_VERSION",
            "packages": {
              "processx": "$PROCESSX_VERSION",
              "jsonlite": "$JSONLITE_VERSION"
            }
          }
          EOF

          # Stage all changes (with verbose output for debugging)
          echo "Staging DESCRIPTION..."
          git add DESCRIPTION
          
          echo "Staging GDAL_VERSION_INFO.json..."
          git add -f inst/GDAL_VERSION_INFO.json
          
          echo "Staging generated R files..."
          if [ -d R ]; then
            git add R/
            echo "  R/ staged ($(git diff --cached --name-only R/ | wc -l) files)"
          else
            echo "  R/ directory not found!"
          fi
          
          echo "Staging documentation files..."
          if [ -d man ]; then
            git add man/
            echo "  man/ staged ($(git diff --cached --name-only man/ | wc -l) files)"
          else
            echo "  man/ directory not found!"
          fi
          
          echo "Staging NAMESPACE..."
          if [ -f NAMESPACE ]; then
            git add NAMESPACE
            echo "  NAMESPACE staged"
          else
            echo "  NAMESPACE file not found!"
          fi
          
          echo ""
          echo "Status of staged changes:"
          git diff --cached --name-only | head -20
          
          if ! git diff --cached --quiet; then
            git commit -m "Release: gdalcli for GDAL $GDAL_VERSION"
            git push origin ${{ needs.validate.outputs.branch_name }} --force
          else
            echo "No changes to commit"
          fi

      - name: Create GitHub release
        if: success() && github.event.inputs.create_release == 'true' && github.ref == 'refs/heads/main' && github.event.inputs.dry_run == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ needs.validate.outputs.tag_name }}
          target_commitish: ${{ needs.validate.outputs.branch_name }}
          name: gdalcli v${{ needs.validate.outputs.package_version }} for GDAL ${{ needs.validate.outputs.gdal_version }}
          draft: false
          prerelease: false
          body: |
            Release of gdalcli for GDAL ${{ needs.validate.outputs.gdal_version }}

            ## Details
            - GDAL Version: ${{ needs.validate.outputs.gdal_version }}
            - Package Version: ${{ needs.validate.outputs.package_version }}-${{ needs.validate.outputs.gdal_version }}
            - Release Branch: `${{ needs.validate.outputs.branch_name }}`
            - Docker Image: `ghcr.io/${{ github.repository }}:gdal-${{ needs.validate.outputs.gdal_version }}-latest`

            ## Installation
            Install from release branch:
            ```r
            remotes::install_github(
              "brownag/gdalcli",
              ref = "${{ needs.validate.outputs.branch_name }}"
            )
            ```

            Pull runtime Docker image:
            ```bash
            docker pull ghcr.io/${{ github.repository }}:gdal-${{ needs.validate.outputs.gdal_version }}-latest
            ```
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build summary
        if: always()
        run: |
          RELEASE_INFO="No (not on main branch)"
          if [ "${{ github.ref }}" = "refs/heads/main" ] && [ "${{ github.event.inputs.create_release }}" = "true" ]; then
            RELEASE_INFO="Yes (${{ needs.validate.outputs.tag_name }})"
          fi

          cat >> $GITHUB_STEP_SUMMARY <<'EOF'
          ## Build Summary

          | Item | Value |
          |------|-------|
          | GDAL Version | ${{ needs.validate.outputs.gdal_version }} |
          | Package Version | ${{ needs.validate.outputs.package_version }}-${{ needs.validate.outputs.gdal_version }} |
          | Release Branch | `${{ needs.validate.outputs.branch_name }}` |
          | Docker Image | `ghcr.io/${{ github.repository }}:gdal-${{ needs.validate.outputs.gdal_version }}-latest` |
          | Build Status | ${{ job.status }} |
          | GitHub Release | ${RELEASE_INFO} |
          | Dry Run | ${{ github.event.inputs.dry_run }} |
          EOF
