% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core-path_handlers.R, R/core-vsi_url.R,
%   R/core-wrapper_handlers.R
\name{path_handlers}
\alias{path_handlers}
\alias{vsi_url.vsis3}
\alias{vsi_url.vsigs}
\alias{vsi_url.vsiaz}
\alias{vsi_url.vsiadls}
\alias{vsi_url.vsioss}
\alias{vsi_url.vsiswift}
\alias{vsi_url.vsicurl}
\alias{vsi_url.vsigzip}
\alias{vsi_url.vsimem}
\alias{vsi_url.vsihdfs}
\alias{vsi_url.vsiwebhdfs}
\alias{vsi_url}
\alias{vsi_url.default}
\alias{wrapper_handlers}
\alias{vsi_url.vsizip}
\alias{vsi_url.vsitar}
\alias{vsi_url.vsi7z}
\alias{vsi_url.vsirar}
\alias{vsi_url.vsisubfile}
\alias{vsi_url.vsicrypt}
\alias{vsi_url.vsicached}
\alias{vsi_url.vsisparse}
\title{Path-Based VSI Handler Methods}
\usage{
\method{vsi_url}{vsis3}(bucket, key, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsigs}(bucket, key, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsiaz}(container, key, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsiadls}(filesystem, path, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsioss}(bucket, key, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsiswift}(bucket, key, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsicurl}(url, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsigzip}(path, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsimem}(filename, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsihdfs}(path, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsiwebhdfs}(url, ..., streaming = FALSE, validate = FALSE)

vsi_url(handler, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{default}(handler, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsizip}(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

\method{vsi_url}{vsitar}(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

\method{vsi_url}{vsi7z}(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

\method{vsi_url}{vsirar}(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

\method{vsi_url}{vsisubfile}(offset, size, filename, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsicrypt}(
  key,
  filename,
  key_format = "plaintext",
  ...,
  streaming = FALSE,
  validate = FALSE
)

\method{vsi_url}{vsicached}(filename, ..., streaming = FALSE, validate = FALSE)

\method{vsi_url}{vsisparse}(filename, ..., streaming = FALSE, validate = FALSE)
}
\arguments{
\item{...}{Handler-specific arguments passed to the corresponding S3 method.
See method documentation for details (e.g., \code{?vsi_url.vsis3}).}

\item{streaming}{Logical. If \code{TRUE}, appends \verb{_streaming} to the handler prefix
(e.g., \verb{/vsis3_streaming/} instead of \verb{/vsis3/}). Streaming handlers are
optimized for sequential-only access and should be used only when random-access
efficiency is not required. Default is \code{FALSE} (random-access, recommended for
Cloud Optimized GeoTIFF and similar formats).}

\item{validate}{Logical. If \code{TRUE}, performs strict validation on path components:
checks for empty strings, illegal characters, and other constraints. Default is
\code{FALSE}, which preserves maximum flexibility for composing URLs to non-existent,
remote, or future paths.}

\item{handler}{Character string identifying the VSI handler prefix (e.g., "vsis3",
"vsizip", "vsiaz"). Dispatches to an S3 method for that handler. Supported values
are listed in the \strong{Methods} section below.}
}
\value{
A character string representing the composed VSI path, suitable for use with
GDAL-aware functions (e.g., \code{sf::read_sf()}, \code{stars::read_stars()}, \code{raster::brick()}).
}
\description{
S3 methods for simple path-based VSI handlers (cloud storage, network, utilities).
Each handler corresponds to a GDAL VSI prefix and composes URLs by concatenating
path components. These handlers support the \code{streaming} parameter to toggle between
random-access (default, efficient) and streaming-only variants.

\code{vsi_url()} is an S3 generic method for composing GDAL Virtual File System
(VSI) URLs across 30+ handlers including cloud storage (S3, GCS, Azure, OSS, Swift),
archive formats (ZIP, TAR, 7z, RAR), and utility handlers (memory, subfile, encryption).

The function supports recursive composition of VSI paths, enabling complex nested
scenarios such as accessing a shapefile within a ZIP archive stored on an S3 bucket.
Authentication is decoupled from URL composition and managed through environment
variables via \code{\link[=set_gdal_auth]{set_gdal_auth()}}.

S3 methods for wrapper/archive VSI handlers that support recursive composition.
These handlers can accept the output of other \code{vsi_url()} calls as their
\code{archive_path} argument, enabling complex nested scenarios like accessing a
shapefile within a ZIP on S3.
}
\details{
\subsection{vsis3: AWS S3 and S3-Compatible Storage}{

\strong{GDAL Version:} ≥ 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsis3/bucket/key} or \verb{/vsis3_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{AWS_ACCESS_KEY_ID} + \code{AWS_SECRET_ACCESS_KEY}
\item \code{AWS_SESSION_TOKEN} (for temporary credentials)
\item \code{AWS_NO_SIGN_REQUEST=YES} (for public buckets)
\item \code{AWS_REGION} (optional)
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: S3 bucket name (e.g., "sentinel-pds")
\item \code{key}: Object key / path within bucket (e.g., "tiles/10/S/DG/2015/12/7/0/B01.jp2")
\item \code{streaming}: Logical. Use \verb{/vsis3_streaming/} for sequential-only access (not recommended
for Cloud Optimized GeoTIFF). Default FALSE.
\item \code{validate}: Logical. If TRUE, check that bucket and key are non-empty. Default FALSE.
}
}

\subsection{vsigs: Google Cloud Storage}{

\strong{GDAL Version:} ≥ 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsigs/bucket/key} or \verb{/vsigs_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{GOOGLE_APPLICATION_CREDENTIALS} (path to JSON credentials file) - recommended
\item \code{GS_OAUTH2_REFRESH_TOKEN} + \code{GS_OAUTH2_CLIENT_ID} + \code{GS_OAUTH2_CLIENT_SECRET}
\item \code{GS_NO_SIGN_REQUEST=YES} (for public buckets)
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: GCS bucket name (e.g., "my_bucket")
\item \code{key}: Object key / path within bucket (e.g., "image.tif")
\item \code{streaming}: Logical. Use \verb{/vsigs_streaming/} for sequential-only access. Default FALSE.
\item \code{validate}: Logical. If TRUE, check that bucket and key are non-empty. Default FALSE.
}
}

\subsection{vsiaz: Microsoft Azure Blob Storage}{

\strong{GDAL Version:} ≥ 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsiaz/container/key} or \verb{/vsiaz_streaming/container/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{AZURE_STORAGE_CONNECTION_STRING} (easiest method)
\item \code{AZURE_STORAGE_ACCOUNT} + \code{AZURE_STORAGE_ACCESS_KEY}
\item \code{AZURE_STORAGE_ACCOUNT} + \code{AZURE_STORAGE_SAS_TOKEN}
\item \code{AZURE_NO_SIGN_REQUEST=YES} (for public containers)
}

\strong{Parameters:}
\itemize{
\item \code{container}: Azure Blob container name (e.g., "container1")
\item \code{key}: Blob key / path within container (e.g., "Points_1.shp")
\item \code{streaming}: Logical. Use \verb{/vsiaz_streaming/} for sequential-only access. Default FALSE.
\item \code{validate}: Logical. If TRUE, check that container and key are non-empty. Default FALSE.
}
}

\subsection{vsiadls: Microsoft Azure Data Lake Storage Gen2}{

\strong{GDAL Version:} ≥ 3.3.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsiadls/filesystem/path/to/file}

\strong{Authentication:} Identical to \verb{/vsiaz/} (uses same AZURE_STORAGE_* environment variables)

\strong{Parameters:}
\itemize{
\item \code{filesystem}: ADLS Gen2 filesystem name
\item \code{path}: Hierarchical path to the file
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check components are non-empty. Default FALSE.
}
}

\subsection{vsioss: Alibaba Cloud Object Storage Service}{

\strong{GDAL Version:} ≥ 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsioss/bucket/key} or \verb{/vsioss_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{OSS_ENDPOINT} (required, e.g., "http://oss-us-east-1.aliyuncs.com")
\item \code{OSS_ACCESS_KEY_ID} + \code{OSS_SECRET_ACCESS_KEY}
\item \code{OSS_SESSION_TOKEN} (for temporary credentials)
\item \code{OSS_NO_SIGN_REQUEST=YES} (for public buckets)
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: OSS bucket name
\item \code{key}: Object key / path within bucket
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check components are non-empty. Default FALSE.
}
}

\subsection{vsiswift: OpenStack Swift}{

\strong{GDAL Version:} ≥ 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsiswift/bucket/key} or \verb{/vsiswift_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \strong{Keystone V3:} \code{OS_IDENTITY_API_VERSION=3}, \code{OS_AUTH_URL}, \code{OS_USERNAME}, \code{OS_PASSWORD},
\code{OS_PROJECT_NAME}, \code{OS_PROJECT_DOMAIN_NAME}
\item \strong{Auth V1:} \code{SWIFT_AUTH_V1_URL}, \code{SWIFT_USER}, \code{SWIFT_KEY}
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: Swift container name
\item \code{key}: Object key / path within container
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check components are non-empty. Default FALSE.
}
}

\subsection{vsicurl: HTTP, HTTPS, FTP}{

\strong{GDAL Version:} ≥ Pre-3.0 (mature in all 3.x versions)

\strong{Syntax:} \verb{/vsicurl/http://...} or \verb{/vsicurl/https://...} or \verb{/vsicurl/ftp://...}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \strong{FTP Basic Auth:} Embed in URL or use environment variables
\item \strong{HTTP Bearer Token:} \code{GDAL_HTTP_BEARER}
\item \strong{Custom Headers:} \code{GDAL_HTTP_HEADER_FILE} (path to text file with \code{Key: Value} headers)
\item \strong{Proxy:} \code{GDAL_HTTP_PROXY} and \code{GDAL_HTTP_PROXYUSERPWD}
}

\strong{Parameters:}
\itemize{
\item \code{url}: Full URL string (including protocol: http://, https://, or ftp://)
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check URL is non-empty. Default FALSE.
}
}

\subsection{vsigzip: GZip-Compressed Files}{

\strong{GDAL Version:} ≥ Pre-3.0 (requires zlib)

\strong{Syntax:} \verb{/vsigzip/path/to/file.gz}

\strong{Important:} This handler decompresses a single GZip file, exposing the decompressed
data stream. It is NOT for reading archives (use \verb{/vsitar/} for TAR.GZ files).

\strong{Parameters:}
\itemize{
\item \code{path}: Path to the .gz file (local or VSI path)
\item \code{streaming}: Ignored (GZip always streams decompression)
\item \code{validate}: Logical. If TRUE, check path is non-empty. Default FALSE.
}
}

\subsection{vsimem: In-Memory Files}{

\strong{GDAL Version:} ≥ Pre-3.0

\strong{Syntax:} \verb{/vsimem/filename}

\strong{Use Case:} For temporary files, VRTs, or conversions that benefit from memory storage
instead of disk I/O.

\strong{Parameters:}
\itemize{
\item \code{filename}: Arbitrary path/name for the virtual file (e.g., "temp.tif" or "vrt/layer.vrt")
\item \code{streaming}: Ignored (memory files are always random-access)
\item \code{validate}: Logical. If TRUE, check filename is non-empty. Default FALSE.
}
}

\subsection{vsihdfs: Hadoop HDFS (Native Protocol)}{

\strong{GDAL Version:} ≥ Pre-3.0

\strong{Syntax:} \verb{/vsihdfs/hdfs://hostname:port/path/to/file}

\strong{Authentication:} Depends on Hadoop cluster configuration (Kerberos, etc.)

\strong{Parameters:}
\itemize{
\item \code{path}: Full HDFS path (e.g., "hdfs://namenode:8020/data/file.tif")
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check path is non-empty. Default FALSE.
}
}

\subsection{vsiwebhdfs: Hadoop WebHDFS (REST API)}{

\strong{GDAL Version:} ≥ Pre-3.0

\strong{Syntax:} \verb{/vsiwebhdfs/http://hostname:port/webhdfs/v1/path/to/file}

\strong{Authentication:} HTTP-based (same as \verb{/vsicurl/}); see \code{\link[=set_gdal_auth]{set_gdal_auth()}}

\strong{Parameters:}
\itemize{
\item \code{url}: Full WebHDFS URL (e.g., "http://namenode:50070/webhdfs/v1/user/data/file.tif")
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check URL is non-empty. Default FALSE.
}
}

\subsection{vsizip: ZIP, KMZ, ODS, XLSX Archives}{

\strong{GDAL Version:} ≥ Pre-3.0 (mature in all 3.x versions)

\strong{Syntax:}
\itemize{
\item Standard (local/regular paths): \verb{/vsizip/path/to/archive.zip/file/in/archive.shp}
\item Explicit chaining (VSI paths): \verb{/vsizip/\{/vsis3/bucket/archive.zip\}//file/in/archive.shp}
}

\strong{Recognized Extensions:} .zip, .kmz, .ods, .xlsx

\strong{Chaining:} Can accept output of other \code{vsi_url()} calls as \code{archive_path}.
If a VSI path is detected, automatic explicit chaining syntax with \code{{...}} and \verb{//}
is applied.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the ZIP archive (local file, VSI path, or HTTP(S) URL)
\item \code{file_in_archive}: Character string or NULL. Path to the file within the archive.
If NULL, returns the archive path itself (useful for inspection).
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, warns about non-recognized archive extensions.
Default FALSE (allows flexibility for extensionless URLs).
}
}

\subsection{vsitar: TAR, TGZ, TAR.GZ Archives}{

\strong{GDAL Version:} ≥ Pre-3.0 (mature in all 3.x versions)

\strong{Syntax:}
\itemize{
\item Standard: \verb{/vsitar/path/to/archive.tar/file/in/archive.tif}
\item Explicit chaining: \verb{/vsitar/\{/vsis3/bucket/archive.tgz\}//file.tif}
}

\strong{Recognized Extensions:} .tar, .tgz, .tar.gz

\strong{Chaining:} Supports recursive composition like \code{vsizip}.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the TAR archive (local, VSI, or HTTP(S))
\item \code{file_in_archive}: Character string or NULL. Path within the archive.
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, warns about non-TAR extensions. Default FALSE.
}
}

\subsection{vsi7z: 7z Archives}{

\strong{GDAL Version:} ≥ 3.7.0 (requires libarchive; also supports .lpk, .lpkx, .mpk, .mpkx, .ppkx)

\strong{Syntax:}
\itemize{
\item Standard: \verb{/vsi7z/path/to/archive.7z/file/in/archive.tif}
\item Explicit chaining: \verb{/vsi7z/\{/vsis3/bucket/archive.7z\}//file.tif}
}

\strong{Recognized Extensions:} .7z, .lpk, .lpkx, .mpk, .mpkx, .ppkx

\strong{Chaining:} Supports recursive composition.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the 7z archive
\item \code{file_in_archive}: Path within the archive, or NULL
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, warns about non-7z extensions. Default FALSE.
}
}

\subsection{vsirar: RAR Archives}{

\strong{GDAL Version:} ≥ 3.7.0 (requires libarchive)

\strong{Syntax:}
\itemize{
\item Standard: \verb{/vsirar/path/to/archive.rar/file/in/archive.tif}
\item Explicit chaining: \verb{/vsirar/\{/vsis3/bucket/archive.rar\}//file.tif}
}

\strong{Recognized Extensions:} .rar

\strong{Chaining:} Supports recursive composition.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the RAR archive
\item \code{file_in_archive}: Path within the archive, or NULL
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, warns about non-RAR extensions. Default FALSE.
}
}

\subsection{vsisubfile: Byte Range Within a File}{

\strong{GDAL Version:} ≥ Pre-3.0

\strong{Syntax:}
\itemize{
\item Standard: \verb{/vsisubfile/OFFSET_SIZE,path/to/file}
\item With VSI chaining: \verb{/vsisubfile/1024_512000,\{/vsis3/bucket/largefile\}}
}

\strong{Purpose:} Exposes a specific byte range (OFFSET and SIZE) of a file as a complete
virtual file, useful for reading portions of large files.

\strong{Parameters:}
\itemize{
\item \code{offset}: Integer. Byte offset where the subfile begins.
\item \code{size}: Integer. Length of the subfile in bytes.
\item \code{filename}: Path to the parent file (local, VSI, or HTTP(S)).
If this is a VSI path, automatic chaining with \code{{...}} is applied.
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, validates that offset and size are positive.
Default FALSE.
}
}

\subsection{vsicrypt: Encrypted Files}{

\strong{GDAL Version:} ≥ Pre-3.0 (requires Crypto++ library)

\strong{Syntax:} \verb{/vsicrypt/key=VALUE,file=\{path_to_file\}}

\strong{Purpose:} On-the-fly encryption/decryption of files. The \code{file} parameter can be
another VSI path to enable scenarios like encrypted archives on S3.

\strong{Key Format:} Can be plaintext or base64-encoded.

\strong{Parameters:}
\itemize{
\item \code{key}: Character string. The encryption key (plaintext).
\item \code{filename}: Path to the file to encrypt/decrypt (can be a VSI path for chaining).
\item \code{key_format}: Character string. "plaintext" (default) or "base64".
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, checks that key and filename are non-empty.
Default FALSE.
}
}

\subsection{vsicached: File Caching Layer}{

\strong{GDAL Version:} ≥ 3.8.0 (earlier versions may use \verb{/vsicache/})

\strong{Syntax:} \verb{/vsicached/\{inner_vsi_path\}} or \verb{/vsicached/local_path}

\strong{Purpose:} Adds an automatic file caching layer around another file/VSI path,
useful for remote data access optimization.

\strong{Chaining:} Supports recursive composition.

\strong{Parameters:}
\itemize{
\item \code{filename}: Path to cache (local, VSI path, or HTTP(S) URL)
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, checks filename is non-empty. Default FALSE.
}
}

\subsection{vsisparse: Sparse File Handler}{

\strong{GDAL Version:} ≥ Pre-3.0

\strong{Syntax:} \verb{/vsisparse/\{inner_vsi_path\}} or \verb{/vsisparse/local_path}

\strong{Purpose:} Creates or reads sparse files (files with unallocated "holes").
Supports recursive composition.

\strong{Parameters:}
\itemize{
\item \code{filename}: Path to the sparse file
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, checks filename is non-empty. Default FALSE.
}
}
}
\section{GDAL Version Support}{


\strong{Minimum GDAL version: 3.6.1} (recommended for production use).

Handler availability across GDAL versions:\tabular{lllll}{
   Handler Family \tab GDAL 3.0.0 \tab GDAL 3.6.1 \tab GDAL 3.7.0 \tab GDAL 3.12.0 \cr
   Cloud (S3, GCS, Azure, OSS, Swift) \tab ✓ \tab ✓ (mature) \tab ✓ \tab ✓ (enhanced) \cr
   Cloud streaming variants \tab ✓ \tab ✓ \tab ✓ \tab ✓ \cr
   Archive (ZIP, TAR, GZip) \tab ✓ \tab ✓ \tab ✓ \tab ✓ \cr
   Archive (7z, RAR) \tab — \tab — \tab ✓ (libarchive) \tab ✓ \cr
   Utility (mem, subfile, crypt, cached, sparse) \tab ✓ \tab ✓ \tab ✓ \tab ✓ \cr
   Network (curl, HDFS, WebHDFS) \tab ✓ \tab ✓ \tab ✓ \tab ✓ \cr
}
}

\section{Methods}{


This is an S3 generic, so packages can provide new implementations for new handlers.
Methods available in this package:

\Sexpr[stage=render,results=rd]{gdalcli:::.methods_vsi_url()}
}

\section{Authentication}{


Credentials for cloud storage handlers must be configured via environment variables.
Use \code{\link[=set_gdal_auth]{set_gdal_auth()}} to set these variables securely:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Set AWS S3 credentials
set_gdal_auth("s3", access_key_id = "...", secret_access_key = "...")

# Set Azure Blob Storage credentials
set_gdal_auth("azure", connection_string = "...")

# Then compose and use the URL
url <- vsi_url("vsis3", bucket = "my-bucket", key = "path/to/file.tif")
}\if{html}{\out{</div>}}
}

\section{Performance Considerations}{

\itemize{
\item \strong{Random-access (default)}: Use \code{streaming = FALSE} (default) for formats like
Cloud Optimized GeoTIFF (COG), which benefit from efficient HTTP Range requests
to read small data windows.
\item \strong{Streaming}: Use \code{streaming = TRUE} only for sequential-only workflows (e.g.,
reading an entire compressed file from start to finish). Streaming through remote
data can be slower due to lack of seek efficiency.
}
}

\examples{
# Public Sentinel-2 data on AWS
vsi_url("vsis3",
  bucket = "sentinel-pds",
  key = "tiles/10/S/DG/2015/12/7/0/B01.jp2"
)

# Private bucket (requires authentication via set_gdal_auth("s3", ...))
vsi_url("vsis3", bucket = "my-private-bucket", key = "data/file.tif")
# Public GCS data
vsi_url("vsigs", bucket = "gcs-bucket", key = "path/to/file.tif")
# Azure Blob Storage
vsi_url("vsiaz", container = "mycontainer", key = "data/shapefile.shp")
# Azure Data Lake Storage Gen2
vsi_url("vsiadls", filesystem = "myfs", path = "dir/file.parquet")
# Alibaba Cloud OSS
vsi_url("vsioss", bucket = "my-bucket", key = "data/file.tif")
# OpenStack Swift
vsi_url("vsiswift", bucket = "container", key = "data/file.tif")
# HTTP(S) URL
vsi_url("vsicurl", url = "https://example.com/data/file.tif")
# Local gzip file
vsi_url("vsigzip", path = "data/file.tif.gz")

# Remote gzip file
vsi_url("vsigzip", path = "/vsicurl/https://example.com/file.tif.gz")
# Temporary in-memory file
vsi_url("vsimem", filename = "temp.tif")

# Nested path in memory
vsi_url("vsimem", filename = "temp/subdir/layer.vrt")
# HDFS path
vsi_url("vsihdfs", path = "hdfs://namenode:8020/user/data/file.tif")
# WebHDFS path
vsi_url("vsiwebhdfs", url = "http://namenode:50070/webhdfs/v1/data/file.tif")
# Simple path-based handler: AWS S3
vsi_url("vsis3", bucket = "sentinel-pds", key = "tiles/10/S/DG/2015/12/7/0/B01.jp2")

# Recursive composition: ZIP archive on S3
s3_zip <- vsi_url("vsis3", bucket = "my-bucket", key = "archive.zip")
vsi_url("vsizip", archive_path = s3_zip, file_in_archive = "data/layer.shp")

# Multi-level nesting: TAR.GZ inside ZIP on S3
inner_vsi <- vsi_url("vsis3", "bucket", "archive.zip")
outer_vsi <- vsi_url("vsizip", inner_vsi, "nested/data.tar.gz")
final_vsi <- vsi_url("vsitar", outer_vsi, "file.tif")

# Simple local ZIP
vsi_url("vsizip", archive_path = "data.zip", file_in_archive = "layer.shp")

# ZIP on HTTP(S)
zip_url <- vsi_url("vsicurl", url = "https://example.com/data.zip")
vsi_url("vsizip", archive_path = zip_url, file_in_archive = "layer.shp")

# ZIP on S3 (recursive composition)
s3_zip <- vsi_url("vsis3", bucket = "my-bucket", key = "archive.zip")
vsi_url("vsizip", archive_path = s3_zip, file_in_archive = "layer.shp")
# TAR.GZ on S3
tar_on_s3 <- vsi_url("vsis3", bucket = "bucket", key = "archive.tar.gz")
vsi_url("vsitar", archive_path = tar_on_s3, file_in_archive = "layer.tif")
# 7z archive
vsi_url("vsi7z", archive_path = "archive.7z", file_in_archive = "data.tif")
# RAR archive
vsi_url("vsirar", archive_path = "archive.rar", file_in_archive = "data.tif")
# Read bytes 1024-513023 (512KB starting at byte 1024)
vsi_url("vsisubfile", offset = 1024, size = 512000, filename = "largefile.dat")

# Subfile within an S3 file
s3_file <- vsi_url("vsis3", bucket = "bucket", key = "largefile")
vsi_url("vsisubfile", offset = 0, size = 10000, filename = s3_file)
# Encrypted file
vsi_url("vsicrypt", key = "mysecretkey", filename = "encrypted_data.bin")

# Encrypted ZIP on S3
s3_zip <- vsi_url("vsis3", bucket = "bucket", key = "encrypted.zip")
vsi_url("vsicrypt", key = "secret", filename = s3_zip)
# Cache an S3 file
s3_file <- vsi_url("vsis3", bucket = "bucket", key = "large_file.tif")
vsi_url("vsicached", filename = s3_file)
# Sparse file wrapper
vsi_url("vsisparse", filename = "sparse_output.vrt")
}
\references{
\itemize{
\item Official GDAL VSI Documentation: \url{https://gdal.org/user/virtual_file_systems.html}
\item GDAL Release Notes: \url{https://github.com/OSGeo/gdal/blob/master/NEWS.md}
\item RFC: GDAL Virtual File Systems: \url{https://gdal.org/development/rfc/rfc25.html}
}
}
\keyword{internal}
