% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core-wrapper_handlers.R
\name{wrapper_handlers}
\alias{wrapper_handlers}
\alias{vsizip_url}
\alias{vsitar_url}
\alias{vsi7z_url}
\alias{vsirar_url}
\alias{vsisubfile_url}
\alias{vsicrypt_url}
\alias{vsicached_url}
\alias{vsisparse_url}
\title{Wrapper-Based VSI Handler Functions}
\usage{
vsizip_url(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

vsitar_url(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

vsi7z_url(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

vsirar_url(
  archive_path,
  file_in_archive = NULL,
  ...,
  streaming = FALSE,
  validate = FALSE
)

vsisubfile_url(
  offset = 0L,
  size = NULL,
  filename,
  ...,
  streaming = FALSE,
  validate = FALSE
)

vsicrypt_url(
  key,
  filename,
  key_format = "plaintext",
  ...,
  streaming = FALSE,
  validate = FALSE
)

vsicached_url(filename, ..., streaming = FALSE, validate = FALSE)

vsisparse_url(filename, ..., streaming = FALSE, validate = FALSE)
}
\description{
Internal functions for wrapper/archive VSI handlers that support recursive composition.
These handlers can accept the output of other \code{vsi_url()} calls as their
\code{archive_path} argument, enabling complex nested scenarios like accessing a
shapefile within a ZIP on S3.
}
\details{
\subsection{vsizip_url: ZIP, KMZ, ODS, XLSX Archives}{

\strong{GDAL Version:} \eqn{\ge} Pre-3.0 (mature in all 3.x versions)

\strong{Syntax:}
\itemize{
\item Standard (local/regular paths): \verb{/vsizip/path/to/archive.zip/file/in/archive.shp}
\item Explicit chaining (VSI paths): \verb{/vsizip/\{/vsis3/bucket/archive.zip\}//file/in/archive.shp}
}

\strong{Recognized Extensions:} .zip, .kmz, .ods, .xlsx

\strong{Chaining:} Can accept output of other \code{vsi_url()} calls as \code{archive_path}.
If a VSI path is detected, automatic explicit chaining syntax with \code{{...}} and \verb{//}
is applied.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the ZIP archive (local file, VSI path, or HTTP(S) URL)
\item \code{file_in_archive}: Character string or NULL. Path to the file within the archive.
If NULL, returns the archive path itself (useful for inspection).
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, warns about non-recognized archive extensions.
Default FALSE (allows flexibility for extensionless URLs).
}
}

\subsection{vsitar_url: TAR, TGZ, TAR.GZ Archives}{

\strong{GDAL Version:} \eqn{\ge} Pre-3.0 (mature in all 3.x versions)

\strong{Syntax:}
\itemize{
\item Standard (local/regular paths): \verb{/vsitar/path/to/archive.tar.gz/file/in/archive.shp}
\item Explicit chaining (VSI paths): \verb{/vsitar/\{/vsis3/bucket/archive.tar.gz\}//file/in/archive.shp}
}

\strong{Recognized Extensions:} .tar, .tgz, .tar.gz, .tar.bz2, .tar.xz, .tar.zst

\strong{Chaining:} Can accept output of other \code{vsi_url()} calls as \code{archive_path}.
If a VSI path is detected, automatic explicit chaining syntax with \code{{...}} and \verb{//}
is applied.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the TAR archive (local file, VSI path, or HTTP(S) URL)
\item \code{file_in_archive}: Character string or NULL. Path to the file within the archive.
If NULL, returns the archive path itself.
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, validates archive extension. Default FALSE.
}
}

\subsection{vsi7z_url: 7z Archives}{

\strong{GDAL Version:} \eqn{\ge} 3.7.0 (with libarchive support)

\strong{Syntax:}
\itemize{
\item Standard (local/regular paths): \verb{/vsi7z/path/to/archive.7z/file/in/archive.shp}
\item Explicit chaining (VSI paths): \verb{/vsi7z/\{/vsis3/bucket/archive.7z\}//file/in/archive.shp}
}

\strong{Recognized Extensions:} .7z, .lpk, .lpkx, .mpk

\strong{Requirements:} libarchive support compiled into GDAL.

\strong{Chaining:} Can accept output of other \code{vsi_url()} calls as \code{archive_path}.
If a VSI path is detected, automatic explicit chaining syntax is applied.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the 7z archive (local file, VSI path, or HTTP(S) URL)
\item \code{file_in_archive}: Character string or NULL. Path to the file within the archive.
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, validates archive extension. Default FALSE.
}
}

\subsection{vsirar_url: RAR Archives}{

\strong{GDAL Version:} \eqn{\ge} 3.7.0 (with libarchive support)

\strong{Syntax:}
\itemize{
\item Standard (local/regular paths): \verb{/vsirar/path/to/archive.rar/file/in/archive.shp}
\item Explicit chaining (VSI paths): \verb{/vsirar/\{/vsis3/bucket/archive.rar\}//file/in/archive.shp}
}

\strong{Recognized Extensions:} .rar

\strong{Requirements:} libarchive support compiled into GDAL.

\strong{Chaining:} Can accept output of other \code{vsi_url()} calls as \code{archive_path}.
If a VSI path is detected, automatic explicit chaining syntax is applied.

\strong{Parameters:}
\itemize{
\item \code{archive_path}: Path to the RAR archive (local file, VSI path, or HTTP(S) URL)
\item \code{file_in_archive}: Character string or NULL. Path to the file within the archive.
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, validates archive extension. Default FALSE.
}
}

\subsection{vsisubfile_url: Byte Range / Subfile Access}{

\strong{GDAL Version:} \eqn{\ge} 2.1.0

\strong{Syntax:}
\itemize{
\item Format: \verb{/vsisubfile/offset,size/\{path\}} or \verb{/vsisubfile/offset/\{path\}}
\item With VSI paths: \verb{/vsisubfile/0,1000/\{/vsis3/bucket/data.bin\}}
}

\strong{Use Cases:} Access specific byte ranges of files; extract embedded rasters
or binary data without copying entire file.

\strong{Parameters:}
\itemize{
\item \code{offset}: Integer. Starting byte position (0-indexed).
\item \code{size}: Integer or NULL. Number of bytes to read. If NULL, reads to end of file.
\item \code{filename}: Character string. File path (local, VSI, or HTTP(S) URL).
}

\strong{Validation:} \code{offset} and \code{size} (if specified) must be non-negative integers.
Size of 0 or negative with non-zero offset is invalid.
}

\subsection{vsicrypt_url: On-the-Fly Encryption/Decryption}{

\strong{GDAL Version:} \eqn{\ge} 2.2.0

\strong{Syntax:}
\itemize{
\item Format: \verb{/vsicrypt/key=\{key_spec\}/alg=\{algorithm\}/\{path\}}
\item Example: \verb{/vsicrypt/key=mypassword/alg=AES_256_GCM//vsis3/bucket/encrypted.bin}
}

\strong{Requirements:} GDAL built with OpenSSL or similar cryptography support.
Algorithm support depends on compile-time options.

\strong{Encryption/Decryption:} Automatically encrypts on write, decrypts on read.
The key and algorithm must be specified before the file path.

\strong{Parameters:}
\itemize{
\item \code{filename}: Character string. File path (local, VSI, or HTTP(S) URL).
\item \code{key}: Character string. The encryption key (plaintext or base64-encoded).
\item \code{key_format}: Character string. One of "plaintext" or "base64". Default "plaintext".
\item \code{alg}: Character string. Algorithm (e.g., "AES_256_GCM", "AES_256_CBC").
Default "AES_256_GCM" (recommended).
}
}

\subsection{vsicached_url: File Caching Layer}{

\strong{GDAL Version:} \eqn{\ge} 3.8.0

\strong{Syntax:}
\itemize{
\item Format: \verb{/vsicached/\{path\}}
\item Example: \verb{/vsicached/\{/vsis3/bucket/data.tif\}}
}

\strong{Use Cases:} Cache frequently accessed remote files to disk for improved
performance. Useful for reading same remote files multiple times or streaming
scenarios with heavy I/O.

\strong{Cache Location:} Stored in temporary directory (configurable via
\code{GDAL_DISABLE_READDIR_ON_OPEN} and related options).

\strong{Parameters:}
\itemize{
\item \code{filename}: Character string. File path (VSI path, HTTP(S) URL, etc.).
Note: Most useful with remote sources (not local files).
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
}
}

\subsection{vsisparse_url: Sparse File Handler}{

\strong{GDAL Version:} \eqn{\ge} 3.1.0

\strong{Syntax:}
\itemize{
\item Format: \verb{/vsisparse/\{path\}}
\item Example: \verb{/vsisparse/\{/vsis3/bucket/sparse_data.bin\}}
}

\strong{Use Cases:} Efficiently handle files with "holes" or unallocated regions.
Useful for large binary files where most of the space is uninitialized or sparse.

\strong{Behavior:} Detects and handles sparse regions within files, potentially
reducing memory footprint and I/O operations for files with significant
unallocated regions.

\strong{Parameters:}
\itemize{
\item \code{filename}: Character string. File path (local, VSI path, or HTTP(S) URL).
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
}
}
}
\examples{
# Simple local ZIP
vsi_url("vsizip", archive_path = "data.zip", file_in_archive = "layer.shp")

# ZIP on HTTP(S)
zip_url <- vsi_url("vsicurl", url = "https://example.com/data.zip")
vsi_url("vsizip", archive_path = zip_url, file_in_archive = "layer.shp")

# ZIP on S3 (recursive composition)
s3_zip <- vsi_url("vsis3", bucket = "my-bucket", key = "archive.zip")
vsi_url("vsizip", archive_path = s3_zip, file_in_archive = "layer.shp")

# Direct function call
vsizip_url(archive_path = "data.zip", file_in_archive = "layer.shp")
# Simple local TAR.GZ
vsi_url("vsitar", archive_path = "data.tar.gz", file_in_archive = "layer.shp")

# TAR.GZ on HTTP(S)
tar_url <- vsi_url("vsicurl", url = "https://example.com/data.tar.gz")
vsi_url("vsitar", archive_path = tar_url, file_in_archive = "layer.shp")

# Direct function call
vsitar_url(archive_path = "data.tar.gz", file_in_archive = "layer.shp")
# Simple local 7z archive
vsi_url("vsi7z", archive_path = "data.7z", file_in_archive = "layer.shp")

# Direct function call
vsi7z_url(archive_path = "data.7z", file_in_archive = "layer.shp")
# Simple local RAR archive
vsi_url("vsirar", archive_path = "data.rar", file_in_archive = "layer.shp")

# Direct function call
vsirar_url(archive_path = "data.rar", file_in_archive = "layer.shp")
# Read first 1000 bytes
vsi_url("vsisubfile", offset = 0L, size = 1000L, filename = "large.bin")

# Read from byte 5000 to end
vsi_url("vsisubfile", offset = 5000L, size = NULL, filename = "data.bin")

# Read from S3 file
vsi_url("vsisubfile", offset = 0L, size = 100L,
        filename = vsi_url("vsis3", bucket = "data", key = "file.bin"))

# Direct function call
vsisubfile_url(offset = 0L, size = 1000L, filename = "large.bin")
# Decrypt with plaintext key
vsi_url("vsicrypt", key = "mypassword", alg = "AES_256_GCM",
        filename = "encrypted.bin")

# Decrypt with base64-encoded key
vsi_url("vsicrypt", key = "bXlwYXNzd29yZA==", key_format = "base64",
        filename = "encrypted.bin")

# Direct function call
vsicrypt_url(key = "mypassword", alg = "AES_256_GCM", filename = "encrypted.bin")
# Cache remote GeoTIFF from S3
vsi_url("vsicached", filename = vsi_url("vsis3", bucket = "data", key = "dem.tif"))

# Cache from HTTP(S)
http_url <- vsi_url("vsicurl", url = "https://example.com/data.tif")
vsi_url("vsicached", filename = http_url)

# Direct function call
vsicached_url(filename = vsi_url("vsis3", bucket = "data", key = "dem.tif"))
# Access sparse file from local filesystem
vsi_url("vsisparse", filename = "sparse_data.bin")

# Access sparse file from S3
vsi_url("vsisparse", filename = vsi_url("vsis3", bucket = "data", key = "sparse.bin"))

# Direct function call
vsisparse_url(filename = "sparse_data.bin")
}
\keyword{internal}
