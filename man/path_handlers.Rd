% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/core-path_handlers.R
\name{path_handlers}
\alias{path_handlers}
\alias{vsis3_url}
\alias{vsigs_url}
\alias{vsiaz_url}
\alias{vsiadls_url}
\alias{vsioss_url}
\alias{vsiswift_url}
\alias{vsicurl_url}
\alias{vsigzip_url}
\alias{vsimem_url}
\alias{vsihdfs_url}
\alias{vsiwebhdfs_url}
\title{Path-Based VSI Handler Functions}
\usage{
vsis3_url(bucket, key, ..., streaming = FALSE, validate = FALSE)

vsigs_url(bucket, key, ..., streaming = FALSE, validate = FALSE)

vsiaz_url(container, key, ..., streaming = FALSE, validate = FALSE)

vsiadls_url(filesystem, path, ..., streaming = FALSE, validate = FALSE)

vsioss_url(bucket, key, ..., streaming = FALSE, validate = FALSE)

vsiswift_url(bucket, key, ..., streaming = FALSE, validate = FALSE)

vsicurl_url(url, ..., streaming = FALSE, validate = FALSE)

vsigzip_url(path, ..., streaming = FALSE, validate = FALSE)

vsimem_url(filename, ..., streaming = FALSE, validate = FALSE)

vsihdfs_url(path, ..., streaming = FALSE, validate = FALSE)

vsiwebhdfs_url(url, ..., streaming = FALSE, validate = FALSE)
}
\description{
Internal functions for simple path-based VSI handlers (cloud storage, network, utilities).
Each handler corresponds to a GDAL VSI prefix and composes URLs by concatenating
path components. These handlers support the \code{streaming} parameter to toggle between
random-access (default, efficient) and streaming-only variants.
}
\details{
\subsection{vsis3_url: AWS S3 and S3-Compatible Storage}{

\strong{GDAL Version:} \eqn{\ge} 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsis3/bucket/key} or \verb{/vsis3_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{AWS_ACCESS_KEY_ID} + \code{AWS_SECRET_ACCESS_KEY}
\item \code{AWS_SESSION_TOKEN} (for temporary credentials)
\item \code{AWS_NO_SIGN_REQUEST=YES} (for public buckets)
\item \code{AWS_REGION} (optional)
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: S3 bucket name (e.g., "sentinel-pds")
\item \code{key}: Object key / path within bucket (e.g., "tiles/10/S/DG/2015/12/7/0/B01.jp2")
\item \code{streaming}: Logical. Use \verb{/vsis3_streaming/} for sequential-only access (not recommended for Cloud Optimized GeoTIFF). Default FALSE.
\item \code{validate}: Logical. If TRUE, check that bucket and key are non-empty. Default FALSE.
}
}

\subsection{vsigs_url: Google Cloud Storage}{

\strong{GDAL Version:} \eqn{\ge} 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsigs/bucket/key} or \verb{/vsigs_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{GOOGLE_APPLICATION_CREDENTIALS} (path to JSON credentials file) - recommended
\item \code{GS_OAUTH2_REFRESH_TOKEN} + \code{GS_OAUTH2_CLIENT_ID} + \code{GS_OAUTH2_CLIENT_SECRET}
\item \code{GS_NO_SIGN_REQUEST=YES} (for public buckets)
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: GCS bucket name (e.g., "my_bucket")
\item \code{key}: Object key / path within bucket (e.g., "image.tif")
\item \code{streaming}: Logical. Use \verb{/vsigs_streaming/} for sequential-only access. Default FALSE.
\item \code{validate}: Logical. If TRUE, check that bucket and key are non-empty. Default FALSE.
}
}

\subsection{vsiaz_url: Microsoft Azure Blob Storage}{

\strong{GDAL Version:} \eqn{\ge} 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsiaz/container/key} or \verb{/vsiaz_streaming/container/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{AZURE_STORAGE_CONNECTION_STRING} (easiest method)
\item \code{AZURE_STORAGE_ACCOUNT} + \code{AZURE_STORAGE_ACCESS_KEY}
\item \code{AZURE_STORAGE_ACCOUNT} + \code{AZURE_STORAGE_SAS_TOKEN}
\item \code{AZURE_NO_SIGN_REQUEST=YES} (for public containers)
}

\strong{Parameters:}
\itemize{
\item \code{container}: Azure Blob container name (e.g., "container1")
\item \code{key}: Blob key / path within container (e.g., "Points_1.shp")
\item \code{streaming}: Logical. Use \verb{/vsiaz_streaming/} for sequential-only access. Default FALSE.
\item \code{validate}: Logical. If TRUE, check that container and key are non-empty. Default FALSE.
}
}

\subsection{vsiadls_url: Microsoft Azure Data Lake Storage Gen2}{

\strong{GDAL Version:} \eqn{\ge} 3.3.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsiadls/filesystem/path/to/file}

\strong{Authentication:} Identical to \verb{/vsiaz/} (uses same AZURE_STORAGE_* environment variables)

\strong{Parameters:}
\itemize{
\item \code{filesystem}: ADLS Gen2 filesystem name
\item \code{path}: Hierarchical path to the file
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check components are non-empty. Default FALSE.
}
}

\subsection{vsioss_url: Alibaba Cloud Object Storage Service}{

\strong{GDAL Version:} \eqn{\ge} 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsioss/bucket/key} or \verb{/vsioss_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \code{OSS_ENDPOINT} (required, e.g., "http://oss-us-east-1.aliyuncs.com")
\item \code{OSS_ACCESS_KEY_ID} + \code{OSS_SECRET_ACCESS_KEY}
\item \code{OSS_SESSION_TOKEN} (for temporary credentials)
\item \code{OSS_NO_SIGN_REQUEST=YES} (for public buckets)
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: OSS bucket name
\item \code{key}: Object key / path within bucket
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check components are non-empty. Default FALSE.
}
}

\subsection{vsiswift_url: OpenStack Swift}{

\strong{GDAL Version:} \eqn{\ge} 3.0.0 (3.6.1+ recommended)

\strong{Syntax:} \verb{/vsiswift/bucket/key} or \verb{/vsiswift_streaming/bucket/key}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \strong{Keystone V3:} \code{OS_IDENTITY_API_VERSION=3}, \code{OS_AUTH_URL}, \code{OS_USERNAME}, \code{OS_PASSWORD},
\code{OS_PROJECT_NAME}, \code{OS_PROJECT_DOMAIN_NAME}
\item \strong{Auth V1:} \code{SWIFT_AUTH_V1_URL}, \code{SWIFT_USER}, \code{SWIFT_KEY}
}

\strong{Parameters:}
\itemize{
\item \code{bucket}: Swift container name
\item \code{key}: Object key / path within container
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check components are non-empty. Default FALSE.
}
}

\subsection{vsicurl_url: HTTP, HTTPS, FTP}{

\strong{GDAL Version:} \eqn{\ge} Pre-3.0 (mature in all 3.x versions)

\strong{Syntax:} \verb{/vsicurl/http://...} or \verb{/vsicurl/https://...} or \verb{/vsicurl/ftp://...}

\strong{Authentication:} Set via environment variables (see \code{\link[=set_gdal_auth]{set_gdal_auth()}}):
\itemize{
\item \strong{FTP Basic Auth:} Embed in URL or use environment variables
\item \strong{HTTP Bearer Token:} \code{GDAL_HTTP_BEARER}
\item \strong{Custom Headers:} \code{GDAL_HTTP_HEADER_FILE} (path to text file with \code{Key: Value} headers)
\item \strong{Proxy:} \code{GDAL_HTTP_PROXY} and \code{GDAL_HTTP_PROXYUSERPWD}
}

\strong{Parameters:}
\itemize{
\item \code{url}: Full URL string (including protocol: http://, https://, or ftp://)
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check URL is non-empty. Default FALSE.
}
}

\subsection{vsigzip_url: GZip-Compressed Files}{

\strong{GDAL Version:} \eqn{\ge} Pre-3.0 (requires zlib)

\strong{Syntax:} \verb{/vsigzip/path/to/file.gz}

\strong{Important:} This handler decompresses a single GZip file, exposing the decompressed
data stream. It is NOT for reading archives (use \verb{/vsitar/} for TAR.GZ files).

\strong{Parameters:}
\itemize{
\item \code{path}: Path to the .gz file (local or VSI path)
\item \code{streaming}: Ignored (GZip always streams decompression)
\item \code{validate}: Logical. If TRUE, check path is non-empty. Default FALSE.
}
}

\subsection{vsimem_url: In-Memory Files}{

\strong{GDAL Version:} \eqn{\ge} Pre-3.0

\strong{Syntax:} \verb{/vsimem/filename}

\strong{Use Case:} For temporary files, VRTs, or conversions that benefit from memory storage
instead of disk I/O.

\strong{Parameters:}
\itemize{
\item \code{filename}: Arbitrary path/name for the virtual file (e.g., "temp.tif" or "vrt/layer.vrt")
\item \code{streaming}: Ignored (memory files are always random-access)
\item \code{validate}: Logical. If TRUE, check filename is non-empty. Default FALSE.
}
}

\subsection{vsihdfs_url: Hadoop HDFS (Native Protocol)}{

\strong{GDAL Version:} \eqn{\ge} Pre-3.0

\strong{Syntax:} \verb{/vsihdfs/hdfs://hostname:port/path/to/file}

\strong{Authentication:} Depends on Hadoop cluster configuration (Kerberos, etc.)

\strong{Parameters:}
\itemize{
\item \code{path}: Full HDFS path (e.g., "hdfs://namenode:8020/data/file.tif")
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check path is non-empty. Default FALSE.
}
}

\subsection{vsiwebhdfs_url: Hadoop WebHDFS (REST API)}{

\strong{GDAL Version:} \eqn{\ge} Pre-3.0

\strong{Syntax:} \verb{/vsiwebhdfs/http://hostname:port/webhdfs/v1/path/to/file}

\strong{Authentication:} HTTP-based (same as \verb{/vsicurl/}); see \code{\link[=set_gdal_auth]{set_gdal_auth()}}

\strong{Parameters:}
\itemize{
\item \code{url}: Full WebHDFS URL (e.g., "http://namenode:50070/webhdfs/v1/user/data/file.tif")
\item \code{streaming}: Logical. Use streaming variant. Default FALSE.
\item \code{validate}: Logical. If TRUE, check URL is non-empty. Default FALSE.
}
}
}
\examples{
# Public Sentinel-2 data on AWS
vsi_url("vsis3",
  bucket = "sentinel-pds",
  key = "tiles/10/S/DG/2015/12/7/0/B01.jp2"
)

# Private bucket (requires authentication via set_gdal_auth("s3", ...))
vsi_url("vsis3", bucket = "my-private-bucket", key = "data/file.tif")

# Direct function call
vsis3_url(bucket = "sentinel-pds", key = "tiles/10/S/DG/2015/12/7/0/B01.jp2")

# Public GCS data
vsi_url("vsigs", bucket = "gcs-bucket", key = "path/to/file.tif")

# Direct function call
vsigs_url(bucket = "gcs-bucket", key = "path/to/file.tif")
# Azure Blob Storage
vsi_url("vsiaz", container = "mycontainer", key = "data/shapefile.shp")

# Direct function call
vsiaz_url(container = "mycontainer", key = "data/shapefile.shp")
# Azure Data Lake Storage Gen2
vsi_url("vsiadls", filesystem = "myfs", path = "dir/file.parquet")

# Direct function call
vsiadls_url(filesystem = "myfs", path = "dir/file.parquet")
# Alibaba Cloud OSS
vsi_url("vsioss", bucket = "my-bucket", key = "data/file.tif")

# Direct function call
vsioss_url(bucket = "my-bucket", key = "data/file.tif")
# OpenStack Swift
vsi_url("vsiswift", bucket = "container", key = "data/file.tif")

# Direct function call
vsiswift_url(bucket = "container", key = "data/file.tif")
# HTTP(S) URL
vsi_url("vsicurl", url = "https://example.com/data/file.tif")

# Direct function call
vsicurl_url(url = "https://example.com/data/file.tif")
# Local gzip file
vsi_url("vsigzip", path = "data/file.tif.gz")

# Remote gzip file
vsi_url("vsigzip", path = "/vsicurl/https://example.com/file.tif.gz")

# Direct function call
vsigzip_url(path = "data/file.tif.gz")
# Temporary in-memory file
vsi_url("vsimem", filename = "temp.tif")

# Nested path in memory
vsi_url("vsimem", filename = "temp/subdir/layer.vrt")

# Direct function call
vsimem_url(filename = "temp.tif")
# HDFS path
vsi_url("vsihdfs", path = "hdfs://namenode:8020/user/data/file.tif")

# Direct function call
vsihdfs_url(path = "hdfs://namenode:8020/user/data/file.tif")
# WebHDFS path
vsi_url("vsiwebhdfs", url = "http://namenode:50070/webhdfs/v1/data/file.tif")

# Direct function call
vsiwebhdfs_url(url = "http://namenode:50070/webhdfs/v1/data/file.tif")
}
\keyword{internal}
